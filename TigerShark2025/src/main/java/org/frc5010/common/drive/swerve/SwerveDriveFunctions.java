// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package org.frc5010.common.drive.swerve;

import org.frc5010.common.drive.pose.DrivePoseEstimator;

import com.pathplanner.lib.util.DriveFeedforwards;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.units.measure.AngularVelocity;
import edu.wpi.first.units.measure.Force;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import swervelib.SwerveDrive;
import swervelib.SwerveModule;

/** Add your docs here. */
public abstract class SwerveDriveFunctions {

    public abstract SwerveModule[] getModules();

    public abstract SwerveModulePosition[] getModulePositions();

    public abstract Field2d getField2d();

    public abstract DrivePoseEstimator initializePoseEstimator();

    /**
     * Gets the current velocity (x, y and omega) of the robot
     *
     * @return A {@link ChassisSpeeds} object of the current velocity
     */
    public abstract ChassisSpeeds getRobotVelocity();

    public abstract ChassisSpeeds getFieldVelocity();

    public abstract void drive(ChassisSpeeds velocity, DriveFeedforwards feedforwards);

    public abstract void driveFieldOriented(ChassisSpeeds velocity);

    public abstract void driveRobotRelative(ChassisSpeeds velocity);

    public abstract void stop();

    public abstract void resetEncoders();

    public abstract double getGyroRate();

    public abstract Command sysIdDriveMotorCommand(SubsystemBase swerveSubsystem);

    public abstract Command sysIdAngleMotorCommand(SubsystemBase swerveSubsystem);

    /**
     * Drive the robot using the {@link SwerveModuleState}, it is recommended to
     * have
     * {@link SwerveDrive#setCosineCompensator(boolean)} set to false for this.<br/>
     *
     * @param robotRelativeVelocity Robot relative {@link ChassisSpeeds}
     * @param states                Corresponding {@link SwerveModuleState} to use
     *                              (not checked against the
     *                              {@param robotRelativeVelocity}).
     * @param feedforwardForces     Feedforward forces generated by set-point
     *                              generator
     */
    public abstract void drive(ChassisSpeeds robotRelativeVelocity, SwerveModuleState[] states,
            Force[] feedforwardForces);

    public abstract Pose2d getPose();

    /**
     * Gets the current module states (azimuth and velocity)
     *
     * @return A list of SwerveModuleStates containing the current module states
     */
    public abstract SwerveModuleState[] getStates();

    /**
     * Get the maximum angular velocity of an azimuth/angle motor in the swerve
     * module.
     *
     * @return {@link AngularVelocity} of the maximum azimuth/angle motor.
     */
    public abstract AngularVelocity getMaximumModuleAngleVelocity();

    public Command run(Runnable runnable) {
        return Commands.run(runnable);
    }
}
